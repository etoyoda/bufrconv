# bufrdump.rb - BUFRデコーダライブラリ

BUFR をデコードしてテキストダンプ、JSON印字、
またはライブラリとして使えば
デコード結果のオブジェクトを yield で投げ返します。
内部で [bufrscan.rb](bufrscan.rb) を呼び出します。

BUFR 電文の構造については [BUFR.md](BUFR.md) を参照してください。

# 単独での使用

> **ruby bufrdump.rb -x** _files ..._

記述子列の反復の範囲を判定し、集約を展開 (eXpand) した結果を
JSON 形式で印字します。

```
$ ruby bufrdump.rb -x tests/A_IUSN01BABJ290000_C_RJTD
_20191029025504_87.bufr
[["#309052",["#301111",["#301001","001001","001002"],"001011","002011",
"002013","002014","002003"],["#301113","008021",["#301011","004001","004002",
"004003"],["#301013","004004","004005","004006"]],["#301114",["#301021",
"005001","006001"],"007030","007031","007007","033024"],["#302049","008002",
"020011","020013","020012","020012","020012","008002"],"022043",
["110000:101000","031002",["#303054","004086","008042","007004","010009",
"005015","006015","012101","012103","011001","011002"],"#END 10"],
["107000:101000","031001",["#303051","004086","008042","007004",
"005015","006015","011061","011062"],"#END 7"]]]
```

※読みにくいので折り返していますが JSON 部は電文あたり1行となります。
**bufrdump.rb -p -x** で JSON が pretty print になります。

> **ruby bufrdump.rb -c** _files ..._

記述子列の反復の範囲を判定し、集約を展開し、
要素記述子の幅・単位・尺度・名称を調べ、操作記述子を適用して解読計画を
構成 (compile) した結果を
JSON 形式で印字します。
**bufrdump.rb -p -c** でJSON が pretty print になります。

印字例は [BufrDB#compile](bufrdump.md#bufrdbcompile-descs) を見てください。


> **ruby bufrdump.rb -d** _files ..._

電文中の実データを毎行1要素の形式で印字 (dump) します。

各 BUFR 報は `bufrscan -d` と同じ概要表示 (JSONオブジェクト) に続き、
実データが印字されます。
実データは数字6桁の記述子から始まります。

> **ruby bufrdump.rb **[**-j**] _files ..._

電文中の実データをサブセット毎に JSON 形式で印字します。
オプション **-j** を省略した場合この動きをします。

各 BUFR 報は `bufrscan -d` と同じ概要表示 (JSONオブジェクト) に続き、
サブセット毎に１行のJSON配列形式のデータ (後述) が印字されます。
BUFR 報の終わりは `7777` だけの行で示されます。

# ライブラリ

基本的に、あらかじめ BufrDB オブジェクトに BUFR 表を読み込んでおいて、
それに BUFRScan が構築する BUFRMsg を与えてデコードします。
たとえば次の例はデコード結果（構造は後述）を
JSON 形式で出力する `bufrdump -j` のように動作します。

```ruby
require 'bufrscan'
db = BufrDB.new(ENV['BUFRDUMPDIR'] || File.dirname($0))
ARGV.each {|fnam|
  BUFRScan.filescan(fnam){|bufrmsg|
    db.decode(bufrmsg, :json, $stdout)
  }
}
```

デコード結果が XML でいうところの DOM にあたります。
DOM 専用のクラスを作って内部の探索を容易にすることも考えられたのですが、
そうせず単なる配列としています。
ひとつの理由は一通り使いこなしてみないと
安直に XPath を模倣した API を作るのが有益かどうか自明ではないこと。
もう一つの理由は
デコード結果を迅速にシリアライズして保存・読み出しできるようにしたいことです。

## class BufrDB

BUFR 表などをメモリに保持して置くためのクラスです。

### BufrDB.setup()

BufrDB インスタンスを作り、BUFR 表などを読み込みます。
表ファイルのあるディレクトリは
環境変数 BUFRDUMPDIR があればそれを用い、
さもなくば Ruby プログラム `$0` の置かれたディレクトリを用います。

### BufrDB.new(_dir_ = '.')

BufrDB インスタンスを作り、BUFR 表などを _dir_ から読み込みます。

現状では次の表が読み込まれます。

|ファイル名|形式|説明|
|----------|----|----|
|table_b_bufr|固定長テキスト|libecbufr で用いる形式の BUFR Table B最新版|
|table_b_bufr.v13|固定長テキスト|table_b_bufr と同じ形式の BUFR Table B 第13版 (相違点のみで可)|
|table_d_bufr|固定長テキスト|libecbufr で用いる形式の BUFR Table B最新版|

### BufrDB#tabconfig _bufrmsg_

BUFRMsg クラスの値 _bufrmsg_ を用いて BufrDB の設定を行います。

現状では、 _bufrmsg_[**:masver**] を参照して、マスター表バージョン13以下で
あればマスター表バージョン13に対応した表を選択するよう設定しています。
真面目にやるならば、ローカル表の選択などをすべきでしょう。

### BufrDB#table_b _fxy_

要素記述子 _fxy_ ("001002" のような String) を与えると
諸元をハッシュで返します。

```
{:type=>"num", :fxy=>"001001", :desc=>"WMO BLOCK NUMBER", :units=>"NUMERIC",
:scale=>0, :refv=>0, :width=>7, :pos=>0}
```

- :type の値が :num, :str, :code, :flags のいずれかとなります。
- デフォルトでは BUFR 表 B マスター表最新バージョンが参照されますが、
  tabconfig でマスター表バージョン 13 以下が指定された場合には
  バージョン13で相違している記述子の意味が変わります。

### BufrDB#expand _descs_

記述子の配列 _descs_ ("001002" のような String の配列)
の反復の範囲を解決して集約を展開したものを返します。
ちょうど bufrdump.rb -x の出力と同じものです。

```
$ ruby bufrdump.rb -x tests/A_ISMN01BABJ050000_C_RJTD_20191105001745_39.bufr
[
  ["#307080",
    ["#301090",
      ["#301004","001001","001002","001015","002001"],
      ["#301011","004001","004002","004003"],["#301012","004004","004005"],
      ["#301021","005001","006001"],"007030","007031"
    ],["#302031",
      ["#302001","010004","010051","010061","010063"],"010062","007004","010009"
    ],["#302035",
      ["#302032","007032","012101","012103","013003"],
      ["#302033","007032","020001"],["#302034","007032","013023"],"007032",
      ["#302004",
        "020010","008002","020011","020013","020012","020012","020012"
      ],
      ["104000:101000","031001",["#302005","008002","020011","020012","020013"],"#END 4"]],
      ["#302036",
        ["105000:105000","031001","008002","020011","020012","020014","020017","#END 5"]
      ],
      ["#302047",["102003:102003","008002","020054","#END 2"]],
後略
```
※読みやすいように折り返しています

- 全体は配列です。
- 集約記述子 (3で始まるもの) は集約の展開結果の配列に置換されます。
  集約の展開状況を把握しやすいよう、もとの集約記述子に '#' を前置したものが残されます。
- 集約の展開は再帰的に行われます。
- 反復記述子 (1で始まるもの) は内部の集約を展開した結果に応じて
  対象記述子数を数え直し、その前後を表示します。
  たとえば "104000:101000" は電文中に "101000" があったが集約の展開により
  対象記述子が 4 個となったため "104000" として扱うと言っています。
- 反復の末尾には "#END 4" のように印をつけます。
  END の後の数は対象記述子数です。

### BufrDB#compile _descs_

記述子の配列 _descs_ ("001002" のような String の配列) について
反復の範囲を判定し、集約を展開し、
要素記述子の幅・単位・尺度・名称を調べ、操作記述子を適用して解読計画を
構成 (compile) した結果を出力します。

解読計画は BufrDecode 仮想機械が読み込むプログラムであり、
ちょうど bufrdump.rb -c で JSON 変換して出力しているのと同じものです。

```
[
  {
    "type": "num",
    "fxy": "001001",
    "desc": "WMO BLOCK NUMBER",
    "units": "NUMERIC",
    "scale": 0,
    "refv": 0,
    "width": 7,
    "pos": 0
  },
  {
    "type": "num",
    "fxy": "001002",
    "desc": "WMO STATION NUMBER",
    "units": "NUMERIC",
    "scale": 0,
    "refv": 0,
    "width": 10,
    "pos": 1
  },
  {
    "type": "str",
    "fxy": "001015",
    "desc": "STATION OR SITE NAME",
    "units": "CCITT IA5",
    "scale": 0,
    "refv": 0,
    "width": 160,
    "pos": 2
  },
後略
```

- 全体はハッシュを要素とする配列です。
  ひとつのハッシュがひとつの記述子を表わします。
- ハッシュには :type と :pos 項目があり、処理の種類と順番になります。
- :type の値が :num, :str, :code, :flags の場合が要素記述子であり、
  BufrDB::table_b の結果のハッシュとなります。
- 反復のはじめと終わりには :type=:repl と :type=:endloop が置かれます。
- :type の値はほかに操作記述子に対応する :op01, :op02, :op04, :op06 が
  あります。
- 原則として expand の結果に対応して記述子が作られますが、
  206yyy を読み込んだ場合は後続するローカル記述子に :width をセットします。
- 205yyy は単なる文字列の要素記述子に翻訳します。
- 未対応の操作記述子を食らわせると BufrDB::ENOSYS を発生させます。

### BufrDB#dprint _bufrmsg_, _outmoode_, _out_ = $stdout

BUFR 報 _bufrmsg_ の記述子列を解読し、_out_.puts で出力します
（出力でなくても puts/flush メソッドがあれば何でも _out_ に渡せます）。

- _outmode_=:expand の場合、上記 expand の結果を JSON 形式で出力します。
  BufrDB#pretty! により pretty print に変更できます。
- _outmode_=:flatten の場合、上記 flatten の結果をコンマ区切りで出力します。
- _outmode_=:compile の場合、上記 compile の結果を JSON 形式で出力します。
  BufrDB#pretty! により pretty print に変更できます。

### BufrDB#decode _bufrmsg_, _outmoode_, _out_ = $stdout

BUFR 報 _bufrmsg_ の記述子列を解読し、
BufrDecode 仮想機械を駆動してデータビット列を解読し、
TreeBuilder を駆動して DOM に相当するデータ構造を構築し、
出力や後続処理への引き渡しをします。

引数 _outmode_ と _out_ の使い方は TreeBuilder のほうを見てください。

### BufrDB#pretty!

JSON 出力するメソッドを JSON.generate から JSON.pretty_generate に変更します。

### BufrDB::ENOSYS < BUFRMsg::ENOSYS

未対応機能を要求されたときに発生します。
BUFRMsg::ENOSYS を経由して Errno::ENOSYS を継承しているので、
それらクラスで捕捉することもできます。

## class BufrDecode

BUFR 記述子列を処理する仮想機械。

### BufrDecode.new _tape_, _bufrmsg_

記述子列を BufrDB#compile で処理したもの（ハッシュの配列）を _tape_ に与え、
BUFRMsg メッセージを _bufrmsg_ に与え、解読の準備をします。

仮想機械が内部的に有する状態は次のようです。

|名前|役割|
|----|----|
|@tape|記述子列|
|@bufrmsg|BUFR報|
|@ymdhack|日付チェック情報 (ymdhack_ini の項参照)|
|@pos|現在処理中の記述子番号（@tape の添字）|
|@cstack|反復処理の状態（反復はネストするのでスタック、初期は空配列）|
|@addwidth|操作記述子 201yyy により臨時変更された記述子幅加算値（無指定時はnil）|
|@addscale|操作記述子 202yyy により臨時変更された尺度加算値（無指定時はnil）|
|@addfield|操作記述子 204yyy により付加されたフィールド幅（無指定時はnil）|

### BufrDecode.ymdhack_ini

記述子列から、発見的手法による日付チェックのための情報を探索します。
年月日が発見できれば、
内部変数 @ymdhack に次のキーを持つハッシュがセットされます。

|名前|役割|
|----|----|
|:ymd|サブセット先頭から年月日 (004001,004002,004003) までのビット数|
|'001011'|サブセット先頭から地点名 001011 までのビット数|
|'001015'|サブセット先頭からコールサイン 001015 までのビット数|

遅延反復の後の要素は対象外です。
または BUFR 報が圧縮されている場合は探索をしません。

この情報は、[BUFRScan#ymdhack](bufrscan.md) で使われます。

### BufrDecode.read_tape _treebuilder_

基本的に現在位置 @pos をひとつ進めて記述子を返すだけですが、
反復があれば対象記述子を繰り返し読み込み、
幅や尺度の臨時変更があれば :width や :scale を変更して返します。

引数 _treebuilder_ には TreeBuilder を与えます。
反復の新しいサイクルを始める時に _treebuilder_.newcycle が、
反復が終わるときに _treebuildeer_.endloop が呼び出されます。

### BufrDecode.run _treebuilder_

引数 _treebuilder_ には TreeBuilder を与えます。
現在位置の記述子を read_tape で読み込み、要素記述子であれば
@bufrmsg からビット列を読み込んで数値または文字列あるいは nil を生成し、
_treebuilder_.showval を通じて出力または後続処理のために蓄積します。
反復を始める時に _treebuilder_.setloop が呼び出されます。

## class TreeBuilder

逐次的に押し込まれる（記述子‐スカラー値）対を反復構造により
木構造に蓄積し、印字または後続処理に回します。

### TreeBuilder.new _mode_, _out_ = $stdout

処理の種類を選択します。

|_mode_|_out_ へのメッセージ|動作|
|------|-----|----|
|:plain|puts/flush|蓄積せず即時に印字します。bufrdump.rb -d の動作です。|
|:json|puts/flush|木構造を構築しJSON化し出力します。bufrdump.rb -j の動作です。|
|:pjson|puts/flush|:jsonと同様ですがJSONにインデントと改行が入ります。bufrdump.rb -p -j の動作です。|
|:direct|newbufr/subset/endbufr|木構造を構築しRubyオブジェクトのまま _out_.subset を通じて後続処理に渡します。 bufr2synop などのアプリケーションのための機能です。|

### TreeBuilder#newbufr _bufrmsg_

新しい BUFR 報の処理を開始します。
処理モード :json, :pjson, :plain であれば _bufrmsg_.to_h が印字されます。
処理モード :direct であれば _out_.newbufr(_bufrmsg_) を呼び出し、
bufr2synop などのアプリケーションはここでヘッダ文字列生成のための設定をします。

### TreeBuilder#newsubset _isubset_, _ptrcheck_

BUFR 報の中の新しいサブセットを開始します。
引数 _isubset_, _ptrcheck_ は処理モード :plain のときの参考印字だけです。

### TreeBuilder#showval _desc_, _val_

木構造に記述子 _desc_ と値 _val_ の対を追加します。
処理モード :plain の場合は追加せずに即 _out_.puts で印字してしまいます。
圧縮電文の場合はサブセット数だけ値が並んだ配列が _val_ に渡されます。

### TreeBuilder#setloop

反復を表わす木構造の分岐を開始します。

### TreeBuilder#newcycle

反復を表わす木構造の分岐の中で次の枝に移動します。

### TreeBuilder#endloop

反復を表わす木構造の分岐を終了します。

### TreeBuilder#endsubset

BUFR 報の中のサブセットの構築を終えます。
処理モード :plain の場合は既に印字するものはないので _out_.flush しかしませんが、その他の場合は木構造を JSON 化印字したり、
_out_.subset で後続処理に回したりします。
圧縮電文で :plain 以外の場合は木構造をサブセットに分解してから
サブセットの数だけ処理が繰り返されます。

### TreeBuilder#endbufr

BUFR 報ごとの終了処理を行います。


# デコード結果の構造

## 簡単な場合（反復のない場合）

まず簡単な場合から。
仮に反復がないBUFR報をデコードした場合、
結果は2要素の配列を要素とする配列となります。
内側の2要素の配列は、（記述子名‐値）対です。
記述子名は間にスペースを入れないで文字列化します。
値は String, Integer, Float, または nil (JSON では null) です。

たとえば SYNOP BUFR の先頭部は反復がありません。
実際の印字から改行を減らして読みやすくすると次のようです:

```javascript
[
  [ "001001", 47 ],
  [ "001002", 401 ],
  [ "001015", "WAKKANAI            " ],
  [ "002001", 1 ],
  [ "004001", 2019 ],
  [ "004002", 10 ],
  [ "004003", 27 ],
  [ "004004", 0 ],
  [ "004005", 0 ],
  [ "005001", 45.415000000000006 ],
  [ "006001", 141.67888000000002 ],
  [ "007030", 2.9000000000000004 ],
  [ "007031", 11.700000000000001 ],
  [ "010004", 100450.0 ],
  [ "010051", 100590.0 ],
  [ "010061", 50.0 ],
  [ "010063", 1 ],
  [ "010062", null ],
  [ "007004", null ],
  [ "010009", null ],
  [ "007032", null ],
  [ "012101", 283.75 ],
  [ "012103", 277.65000000000003 ],
  [ "013003", null ],
  [ "007032", null ],
  [ "020001", 20000.0 ],
  // 後略
]
```

一見するとキー・バリュー・ペアのように見えます。
ハッシュ (JSON オブジェクト) ではなく配列にするのは次のような理由です：

- 記述子の順番に意味がある。たとえば座標記述子（クラス 01～07）が非座標の要素記述子の値を修飾するような意味付けがあります。
- 同一記述子が複数回出現しうる。上の例では 007032 (測器の高さ) が2回現れます。

SYNOP テンプレートにはこの後も多数の 007032 が現れて、
それぞれ直後数個の記述子のデータに
対する測器の高さを与えます。
しかし「数個」が何個かは文法的に判断する方法はなく、
気象測器に対する常識で判断するしかありません。

なお、値を伴いうる記述子は今のところ次の３通りあります。

- 要素記述子 ("0xxyyy" の形)
- 操作記述子 "204yyy" による付加フィールド
- 操作記述子 "206yyy" による挿入文字列

## 固定長の反復がある場合

固定長の反復がある場合は、
反復記述子 "1xxyyy" （ダミーの値 "REPLICATION" を伴う）の後に
二重の配列が挿入されます。
最も外側の配列が反復の範囲です。
次に外側の配列が反復数の数だけ並びます。
その中に（記述子名‐値）対が並びます。

```javascript
[
  //前略
  ["007032",null],
  ["102002","REPLICATION"],
  [
    [
      ["004024",-6],
      ["013011",null]
    ],[
      ["004024",-12],
      ["013011",3.0]
    ]
  ],
  ["007032",null],
  ["004024",-12],
  ["004024",0],
  ["012111",null],
  //後略
]
```

## 遅延反復がある場合

遅延反復がある場合は、反復記述子の後に反復数があって、その後に二重配列が入ります。
これは TEMP 報の例です：

```javascript
[
  //前略
  ["008002",null],
  ["022043",null],
  ["101000","REPLICATION"],
  ["031002",66],
  [
    [
      ["004086",0],
      ["008042",131072],
      ["007004",91850.0],
      ["010009",936],
      ["005015",0.0],
      ["006015",0.0],
      ["012101",279.85],
      ["012103",265.45],
      ["011001",203],
      ["011002",4.0]
    ],[
      ["004086",113],
      ["008042",65536],
      ["007004",85000.0],
      ["010009",1576],
      ["005015",-0.00075],
      ["006015",0.0037700000000000003],
      ["012101",279.85],
      ["012103",262.95],
      ["011001",303],
      ["011002",5.0]
    ], // 後略あと64回続いて反復の外に出る
]
```

## 遅延反復が反復数ゼロとなった場合

特に SYNOP BUFR では多数の遅延反復が反復数ゼロとなります。
その場合、二重配列が空の一重配列となります。
だって反復数（＝０）個だけ内側配列が並んでいるでしょう？

反復を見出すのに、「記述子名があるべきところに Array があれば反復」という
ロジックを使っていると、ここで nil を得てハマりますので注意してください。

```javascript
[
  //前略
  ["020012",61],
  ["020012",60],
  ["101000","REPLICATION"],
  ["031001",0],
  [],
  ["105000","REPLICATION"],
  ["031001",0],
  [],
  //後略
]
```

# bufrdump.rb - BUFRデコーダライブラリ

BUFR をデコードしてテキストダンプ、JSON印字、
またはライブラリとして使えば
デコード結果のオブジェクトを yield で投げ返します。
内部で [bufrscan.rb](bufrscan.rb) を呼び出します。

# 単独での使用

> **ruby bufrdump.rb -x** _files ..._

記述子列の反復の範囲を判定し、集約を展開 (eXpand) した結果を
JSON 形式で印字します。

> **ruby bufrdump.rb -c** _files ..._

記述子列の反復の範囲を判定し、集約を展開し、
要素記述子の幅・単位・尺度・名称を調べ、操作記述子を適用して解読計画を
構成 (compile) した結果を
JSON 形式で印字します。

> **ruby bufrdump.rb -d** _files ..._

電文中の実データを毎行1要素の形式で印字 (dump) します。

各 BUFR 報は `bufrscan -d` と同じ概要表示 (JSONオブジェクト) に続き、
実データが印字されます。
実データは数字6桁の記述子から始まります。

> **ruby bufrdump.rb **[**-j**] _files ..._

電文中の実データをサブセット毎に JSON 形式で印字します。
オプション **-j** を省略した場合この動きをします。

各 BUFR 報は `bufrscan -d` と同じ概要表示 (JSONオブジェクト) に続き、
サブセット毎に１行のJSON配列形式のデータ (後述) が印字されます。
BUFR 報の終わりは `7777` だけの行で示されます。

# ライブラリ

基本的に、あらかじめ BufrDB オブジェクトに BUFR 表を読み込んでおいて、
それに BUFRScan が構築する BUFRMsg を与えてデコードします。
たとえば次の例はデコード結果（構造は後述）を
JSON 形式で出力する `bufrdump -j` のように動作します。

```ruby
require 'bufrscan'
db = BufrDB.new(ENV['BUFRDUMPDIR'] || File.dirname($0))
ARGV.each {|fnam|
  BUFRScan.filescan(fnam){|bufrmsg|
    db.decode(bufrmsg, :json, $stdout)
  }
}
```

デコード結果が XML でいうところの DOM にあたります。
DOM 専用のクラスを作って内部の探索を容易にすることも考えられたのですが、
そうせず単なる配列としています。
ひとつの理由は一通り使いこなしてみないと
安直に XPath を模倣した API を作るのが有益かどうか自明ではないこと。
もう一つの理由は
デコード結果を迅速にシリアライズして保存・読み出しできるようにしたいことです。

## class BufrDB

BUFR 表などをメモリに保持して置くためのクラスです。

### BufrDB.new(_dir_ = '.')

BufrDB インスタンスを作り、BUFR 表などを _dir_ から読み込みます。

**TODO**: `BufrDB.new(ENV['BUFRDUMPDIR'] || File.dirname($0))` の形の
呼び出し方が通例になったのでクラスメソッドを作りましょう。

### BufrDB#expand _descs_

記述子の配列 _descs_ の集約と反復を展開したものを返します。

### BufrDB#compile _descs_

## class BufrDecode



## class TreeBuilder

# デコード結果の構造


BUFR 電文の構造については [BUFR.md](BUFR.md) を参照してください。

まず簡単な場合から。
仮に集約がないBUFR報をデコードした場合、
結果は2要素の配列を要素とする配列となります。
内側の2要素の配列は、記述子名と値の対です。
記述子名は間にスペースを入れないで文字列化します。
値は String, Integer, Float, または nil (JSON では null) です。

たとえば SYNOP BUFR の先頭部は反復がありません。
実際の印字から改行を減らして読みやすくすると次のようです:

```json
[
  [ "001001", 47 ],
  [ "001002", 401 ],
  [ "001015", "WAKKANAI            " ],
  [ "002001", 1 ],
  [ "004001", 2019 ],
  [ "004002", 10 ],
  [ "004003", 27 ],
  [ "004004", 0 ],
  [ "004005", 0 ],
  [ "005001", 45.415000000000006 ],
  [ "006001", 141.67888000000002 ],
  [ "007030", 2.9000000000000004 ],
  [ "007031", 11.700000000000001 ],
  [ "010004", 100450.0 ],
  [ "010051", 100590.0 ],
  [ "010061", 50.0 ],
  [ "010063", 1 ],
  [ "010062", null ],
  [ "007004", null ],
  [ "010009", null ],
  [ "007032", null ],
  [ "012101", 283.75 ],
  [ "012103", 277.65000000000003 ],
  [ "013003", null ],
  [ "007032", null ],
  [ "020001", 20000.0 ],
  ...
```

一見するとキー・バリュー・ペアのように見えます。
ハッシュ (JSON オブジェクト) ではなく配列にするのは何故でしょうか。

- 記述子の順番に意味がある。たとえば座標記述子（クラス 01～07）が非座標の要素記述子の値を修飾するような意味付けがあります。
- 同一記述子が複数回出現しうる。上の例では 007032 (測器の高さ) が2回現れます。


